<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boolean Expression Analyzer & Truth Table Generator</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    <!-- Math.js Library for expression parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.1/math.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom scrollbar for a more modern look */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #111827;
        }
        ::-webkit-scrollbar-thumb {
            background: #374151;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #4b5563;
        }
        .copy-btn-icon {
            transition: transform 0.2s ease-in-out;
        }
        .copy-btn:hover .copy-btn-icon {
            transform: scale(1.1);
        }
        /* K-Map specific styles */
        #kmap-grid {
            grid-template-columns: 3rem repeat(var(--kmap-cols, 4), 1fr);
            grid-template-rows: 3rem repeat(var(--kmap-rows, 4), 1fr);
        }
    </style>
</head>
<body class="bg-gray-900 text-white antialiased">

    <div class="container mx-auto p-4 sm:p-6 md:p-8 max-w-6xl">

        <!-- Header Section -->
        <header class="text-center mb-8">
            <h1 class="text-3xl sm:text-4xl md:text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500">
                Boolean Expression Analyzer
            </h1>
            <p class="text-gray-400 mt-2 text-lg">
                Generate Truth Tables, Canonical Forms, and K-Maps
            </p>
        </header>

        <!-- Input Section -->
        <div class="bg-gray-800 p-6 rounded-2xl shadow-lg border border-gray-700 sticky top-4 z-10 backdrop-blur-sm bg-opacity-80">
            <div>
                <label for="expressionInput" class="block text-sm font-medium text-gray-300 mb-2">Enter Boolean Expression:</label>
                <input type="text" id="expressionInput" class="w-full bg-gray-700 border border-gray-600 text-white rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:outline-none transition" placeholder="(A && B) || !C">
                <p class="text-xs text-gray-500 mt-2">
                    Use variables (A, B), operators: <code class="bg-gray-900 px-1 rounded">and</code>, <code class="bg-gray-900 px-1 rounded">or</code>, <code class="bg-gray-900 px-1 rounded">not</code>, <code class="bg-gray-900 px-1 rounded">xor</code> or symbols <code class="bg-gray-900 px-1 rounded">&&</code>, <code class="bg-gray-900 px-1 rounded">||</code>, <code class="bg-gray-900 px-1 rounded">!</code>, <code class="bg-gray-900 px-1 rounded">^</code>.
                </p>
            </div>
            <div class="flex flex-col sm:flex-row gap-3 mt-4">
                <button id="generateBtn" class="w-full sm:w-1/2 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-blue-500">
                    Generate
                </button>
                <button id="clearBtn" class="w-full sm:w-1/2 bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-gray-500">
                    Clear
                </button>
            </div>
        </div>

        <!-- Error Display Section -->
        <div id="errorContainer" class="mt-6 p-4 bg-red-900/50 border border-red-700 text-red-300 rounded-lg hidden"></div>

        <!-- Output Section -->
        <div id="outputContainer" class="mt-8 hidden">
            
            <!-- Analysis and Canonical Forms -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                <!-- Minterms Card -->
                <div class="bg-gray-800 p-6 rounded-2xl shadow-lg border border-gray-700">
                    <h3 class="text-xl font-semibold mb-3 text-green-300">Sum of Products (SOP)</h3>
                    <div class="flex items-center justify-between">
                        <p id="minterms" class="text-lg font-mono bg-gray-700 px-3 py-1 rounded"></p>
                        <button class="copy-btn p-2 rounded-lg hover:bg-gray-700" data-copy-target="minterms">
                            <svg class="w-5 h-5 text-gray-400 copy-btn-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                        </button>
                    </div>
                </div>

                <!-- Maxterms Card -->
                <div class="bg-gray-800 p-6 rounded-2xl shadow-lg border border-gray-700">
                    <h3 class="text-xl font-semibold mb-3 text-orange-300">Product of Sums (POS)</h3>
                     <div class="flex items-center justify-between">
                        <p id="maxterms" class="text-lg font-mono bg-gray-700 px-3 py-1 rounded"></p>
                        <button class="copy-btn p-2 rounded-lg hover:bg-gray-700" data-copy-target="maxterms">
                            <svg class="w-5 h-5 text-gray-400 copy-btn-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                        </button>
                    </div>
                </div>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <!-- Truth Table -->
                <div class="order-2 lg:order-1">
                    <h2 class="text-2xl font-bold text-center mb-4">Truth Table</h2>
                    <div class="overflow-x-auto bg-gray-800 rounded-2xl shadow-lg border border-gray-700 max-h-[60vh] overflow-y-auto">
                        <table class="min-w-full text-center">
                            <thead id="tableHeader" class="bg-gray-700 sticky top-0"></thead>
                            <tbody id="tableBody" class="divide-y divide-gray-700"></tbody>
                        </table>
                    </div>
                </div>

                <!-- K-Map -->
                <div id="kmapContainer" class="order-1 lg:order-2">
                    <h2 class="text-2xl font-bold text-center mb-4">Karnaugh Map</h2>
                     <div id="kmap-card" class="bg-gray-800 p-4 sm:p-6 rounded-2xl shadow-lg border border-gray-700 flex flex-col items-center justify-center min-h-[300px]">
                        <!-- K-Map will be generated here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <footer class="text-center text-gray-500 mt-12 text-sm">
            <p>A COA Project | Built with Gemini & VS Code</p>
        </footer>
    </div>

    <script>
        // DOM Element References
        const expressionInput = document.getElementById('expressionInput');
        const generateBtn = document.getElementById('generateBtn');
        const clearBtn = document.getElementById('clearBtn');
        const outputContainer = document.getElementById('outputContainer');
        const errorContainer = document.getElementById('errorContainer');
        const tableHeader = document.getElementById('tableHeader');
        const tableBody = document.getElementById('tableBody');
        const mintermsEl = document.getElementById('minterms');
        const maxtermsEl = document.getElementById('maxterms');
        const kmapCard = document.getElementById('kmap-card');

        // Event Listeners
        generateBtn.addEventListener('click', handleGeneration);
        clearBtn.addEventListener('click', clearAll);
        expressionInput.addEventListener('keyup', (event) => {
            if (event.key === 'Enter') handleGeneration();
        });

        document.addEventListener('click', (e) => {
            const copyBtn = e.target.closest('.copy-btn');
            if (copyBtn) {
                const targetId = copyBtn.dataset.copyTarget;
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    copyToClipboard(targetElement.textContent, copyBtn);
                }
            }
        });

        /**
         * Orchestrator function to handle the generation process.
         */
        function handleGeneration() {
            hideError();
            clearOutput();

            try {
                // 1. Get, normalize, and validate input
                const rawExpression = expressionInput.value.trim();
                if (!rawExpression) {
                    showError("Please enter a boolean expression.");
                    return;
                }
                const expression = normalizeExpression(rawExpression);

                // 2. Parse expression and find variables
                const node = math.parse(expression);
                const variables = findVariables(node).sort();
                
                if (variables.length > 8) {
                     showError("Too many variables. Please use 8 or fewer variables for performance.");
                     return;
                }

                // 3. Generate truth table data
                const { truthTableResults, minterms, maxterms } = generateTruthTableData(node, variables, expression);

                // 4. Render all UI components
                renderTruthTable(truthTableResults, [...variables, rawExpression]);
                renderCanonicalForms(variables, minterms, maxterms);
                renderKMap(variables, truthTableResults.map(row => row[row.length - 1]));

                // 5. Show the results
                outputContainer.classList.remove('hidden');

            } catch (err) {
                showError(`Invalid Expression: ${err.message}`);
                clearOutput();
            }
        }

        /**
         * Replaces symbolic operators with their keyword equivalents.
         */
        function normalizeExpression(expr) {
            return expr.replace(/&&/g, ' and ')
                       .replace(/\|\|/g, ' or ')
                       .replace(/!/g, ' not ')
                       .replace(/\^/g, ' xor ')
                       .replace(/&/g, ' and ')
                       .replace(/\|/g, ' or ');
        }
        
        /**
         * Finds all unique variables in the parsed expression.
         */
        function findVariables(node) {
            const variables = new Set();
            node.traverse((currentNode) => {
                if (currentNode.isSymbolNode && !math.hasOwnProperty(currentNode.name)) {
                    variables.add(currentNode.name);
                }
            });
            return Array.from(variables);
        }

        /**
         * Generates the data for the truth table, minterms, and maxterms.
         */
        function generateTruthTableData(node, variables, expression) {
            const numVars = variables.length;
            const truthTableResults = [];
            const minterms = [];
            const maxterms = [];
            
            if (numVars === 0) {
                 const result = node.evaluate() ? 1 : 0;
                 truthTableResults.push([result]);
                 if(result === 1) minterms.push(0); else maxterms.push(0);
            } else {
                const numRows = Math.pow(2, numVars);
                for (let i = 0; i < numRows; i++) {
                    const scope = {};
                    const rowValues = [];
                    for (let j = 0; j < numVars; j++) {
                        const value = (i >> (numVars - 1 - j)) & 1;
                        scope[variables[j]] = value;
                        rowValues.push(value);
                    }
                    const result = node.evaluate(scope) ? 1 : 0;
                    rowValues.push(result);
                    truthTableResults.push(rowValues);
                    
                    if (result === 1) minterms.push(i);
                    else maxterms.push(i);
                }
            }
            return { truthTableResults, minterms, maxterms };
        }

        /**
         * Renders the truth table in the DOM.
         */
        function renderTruthTable(data, headers) {
            tableHeader.innerHTML = '';
            tableBody.innerHTML = '';
            
            const headerRow = document.createElement('tr');
            headers.forEach((header, index) => {
                const th = document.createElement('th');
                th.className = 'px-4 py-3 text-sm font-semibold tracking-wider';
                if(index < headers.length - 1) th.classList.add('border-r', 'border-gray-600');
                th.innerHTML = header;
                headerRow.appendChild(th);
            });
            tableHeader.appendChild(headerRow);
            
            data.forEach(rowData => {
                 const row = document.createElement('tr');
                 row.className = 'even:bg-gray-800 odd:bg-gray-900/50';
                 rowData.forEach((cellData, index) => {
                    const td = document.createElement('td');
                    td.className = 'px-4 py-2';
                    if(index < rowData.length - 1) td.classList.add('border-r', 'border-gray-600');
                    if (index === rowData.length - 1) {
                       td.className += ' font-bold text-lg';
                       td.classList.add(cellData === 1 ? 'text-green-400' : 'text-red-400');
                    }
                    td.textContent = cellData;
                    row.appendChild(td);
                 });
                 tableBody.appendChild(row);
            });
        }
        
        /**
         * Renders the Minterm and Maxterm information.
         */
        function renderCanonicalForms(variables, minterms, maxterms) {
            const varString = variables.join(',');
            mintermsEl.textContent = `Σm(${minterms.join(', ')})`;
            maxtermsEl.textContent = `ΠM(${maxterms.join(', ')})`;
        }

        /**
         * Renders the K-Map if applicable (2, 3, or 4 variables).
         */
        function renderKMap(variables, results) {
            const n = variables.length;
            kmapCard.innerHTML = '';
            if (n < 2 || n > 4) {
                kmapCard.innerHTML = `<p class="text-gray-400">K-Map is only available for 2, 3, or 4 variables.</p>`;
                return;
            }

            const kmapMappings = {
                2: [0, 1, 2, 3],
                3: [0, 1, 3, 2, 4, 5, 7, 6],
                4: [0, 1, 3, 2, 4, 5, 7, 6, 12, 13, 15, 14, 8, 9, 11, 10]
            };
            const grayCode = ['00', '01', '11', '10'];

            let rows, cols, rowVars, colVars;
            if (n === 2) { [rows, cols] = [2, 2]; [rowVars, colVars] = [variables[0], variables[1]]; }
            else if (n === 3) { [rows, cols] = [2, 4]; [rowVars, colVars] = [variables[0], variables.slice(1).join('')]; }
            else { [rows, cols] = [4, 4]; [rowVars, colVars] = [variables.slice(0, 2).join(''), variables.slice(2).join('')]; }
            
            const grid = document.createElement('div');
            grid.id = 'kmap-grid';
            grid.className = 'grid gap-1 font-mono text-center';
            grid.style.setProperty('--kmap-cols', cols);
            grid.style.setProperty('--kmap-rows', rows);

            // Top-left corner (variable labels)
            grid.innerHTML += `<div class="p-2 text-xs text-gray-400 flex items-end justify-start">${rowVars}<span class="text-lg mx-1">\\</span>${colVars}</div>`;

            // Column headers
            for (let c = 0; c < cols; c++) grid.innerHTML += `<div class="p-2 font-semibold">${grayCode[c]}</div>`;
            
            // Row headers and cells
            const mapping = kmapMappings[n];
            for (let r = 0; r < rows; r++) {
                grid.innerHTML += `<div class="p-2 font-semibold">${grayCode[r]}</div>`;
                for (let c = 0; c < cols; c++) {
                    const resultIndex = mapping[r * cols + c];
                    const result = results[resultIndex];
                    const bgColor = result === 1 ? 'bg-green-500/30' : 'bg-red-500/20';
                    grid.innerHTML += `<div class="${bgColor} rounded flex items-center justify-center text-lg font-bold">${result}</div>`;
                }
            }
            kmapCard.appendChild(grid);
        }

        /**
         * Clears all inputs and outputs from the UI.
         */
        function clearAll() {
            expressionInput.value = '';
            clearOutput();
            hideError();
        }

        /**
         * Clears only the output containers.
         */
        function clearOutput() {
            outputContainer.classList.add('hidden');
            tableBody.innerHTML = '';
            tableHeader.innerHTML = '';
            mintermsEl.textContent = '';
            maxtermsEl.textContent = '';
            kmapCard.innerHTML = '';
        }

        function showError(message) {
            errorContainer.textContent = message;
            errorContainer.classList.remove('hidden');
        }

        function hideError() {
            errorContainer.classList.add('hidden');
        }

        /**
         * Copies text to clipboard and provides user feedback.
         */
        function copyToClipboard(text, buttonElement) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            // Use execCommand for broader compatibility in iframe environments
            try {
                document.execCommand('copy');
                const originalIcon = buttonElement.innerHTML;
                buttonElement.innerHTML = `<svg class="w-5 h-5 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>`;
                setTimeout(() => {
                    buttonElement.innerHTML = originalIcon;
                }, 1500);
            } catch (err) {
                console.error('Failed to copy text: ', err);
            }
            document.body.removeChild(textarea);
        }
    </script>
</body>
</html>

