<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boolean Expression Analyzer & Truth Table Generator</title>
    <link href="/public/tailwind.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.1/math.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .font-mono {
            font-family: 'Fira Code', monospace;
        }
        /* Custom scrollbar for a polished look */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #111827; }
        ::-webkit-scrollbar-thumb { background: #374151; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #4b5563; }
        
        /* Active tab styling (from user's code) */
        .tab-btn.active {
            background: linear-gradient(90deg, #3b82f6 60%, #9333ea 100%);
            color: #fff;
            font-weight: bold;
            box-shadow: 0 2px 12px #3b82f6aa;
            border-bottom: 3px solid #9333ea;
            letter-spacing: 0.5px;
            transform: scale(1.08);
        }
        .tab-btn {
            font-weight: 700;
            outline: none;
            transition: box-shadow 0.2s, background 0.2s, color 0.2s, transform 0.2s;
            background: linear-gradient(90deg, #1e293b 60%, #312e81 100%);
            color: #a5b4fc;
            margin-right: 2px;
            border-radius: 0.5rem 0.5rem 0 0;
            letter-spacing: 0.5px;
        }
        .tab-btn:focus {
            box-shadow: 0 0 0 2px #9333ea;
            background: linear-gradient(90deg, #6366f1 60%, #9333ea 100%);
            color: #fff;
        }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        /* Modal transition styles */
        #instructionsModal {
            transition: opacity 0.3s ease;
        }
        
        /* K-Map grid styles using CSS variables for dynamic sizing */
        #kmap-grid {
            grid-template-columns: 3rem repeat(var(--kmap-cols, 4), 1fr);
            grid-template-rows: 3rem repeat(var(--kmap-rows, 4), 1fr);
        }

        /* Circuit Diagram SVG styles */
        .gate-body { fill: #374151; stroke: #9ca3af; stroke-width: 2; }
        .wire { stroke: #9ca3af; stroke-width: 2; fill: none; }
        .input-label { font-size: 16px; font-weight: bold; fill: #d1d5db; text-anchor: start; }
        .wire-junction { fill: #60a5fa; }
    </style>
</head>
<body class="bg-gray-900 text-white antialiased">

    <button id="openInstructionsBtn" class="fixed bottom-6 right-6 bg-blue-600 text-white rounded-full w-14 h-14 flex items-center justify-center shadow-lg hover:bg-blue-700 transition-transform transform hover:scale-110 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900 focus:ring-blue-500 z-30">
        <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
    </button>

    <div id="instructionsModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50 hidden pointer-events-none opacity-0">
        <div class="bg-gray-800 border border-gray-700 rounded-2xl shadow-xl max-w-2xl w-full p-6 sm:p-8 transform transition-transform scale-95">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-blue-400">How to Use the Analyzer</h2>
                <button id="closeInstructionsBtn" class="text-gray-400 hover:text-white text-3xl leading-none">&times;</button>
            </div>
            <div class="text-gray-300 space-y-4 max-h-[70vh] overflow-y-auto pr-2">
                <div>
                    <h3 class="font-semibold text-lg text-white mb-1">1. Enter Expression</h3>
                    <p>Type your boolean expression in the input box. Use variables like <code class="font-mono bg-gray-700 px-1 rounded">A, B, C</code>.</p>
                    <p class="mt-1">You can use keywords (<code class="font-mono bg-gray-700 px-1 rounded">and, or, not, xor</code>) or symbols (<code class="font-mono bg-gray-700 px-1 rounded">&&, ||, !, ^</code>). Basic algebraic notation (<code class="font-mono bg-gray-700 px-1 rounded">AB+C</code>, <code class="font-mono bg-gray-700 px-1 rounded">A'</code>) is also supported.</p>
                </div>
                <div>
                    <h3 class="font-semibold text-lg text-white mb-1">2. Generate & Analyze</h3>
                    <p>Click "Generate" to see a full analysis organized into tabs:</p>
                    <ul class="list-disc list-inside mt-2 space-y-1">
                        <li><b class="text-blue-300">Analysis:</b> View the Minterms, Maxterms, complete Truth Table, and a Karnaugh Map (for 2-4 variables).</li>
                        <li><b class="text-green-300">Simplification:</b> Get an algebraically simplified version of your expression.</li>
                        <li><b class="text-purple-300">Circuit Diagram:</b> See a visual, accurately wired logic gate diagram of your original expression.</li>
                        <li><b class="text-orange-300">Universal Gates:</b> View the simplified expression converted to use only NAND or only NOR gates.</li>
                    </ul>
                </div>
                <div class="border-t border-gray-700 pt-4 mt-4">
                     <p class="font-bold text-center">COA - PROJECT</p>
                     <p class="text-sm text-gray-400 text-center mt-2">
                        Made by:<br>
                        AANISH NITHIN A (RA2411003010070)<br>
                        AJAY DHARRSAN TR (RA2411003010071)
                    </p>
                </div>
            </div>
        </div>
    </div>

    <div class="container mx-auto p-2 sm:p-4 md:p-8 max-w-6xl">
        <header class="text-center mb-8">
            <h1 class="text-3xl sm:text-4xl md:text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500">
                Boolean Expression Analyzer
            </h1>
            <p class="text-gray-400 mt-2 text-lg">
                Truth Tables, K-Maps, Simplification, Circuit Diagrams & More
            </p>
        </header>

        <div class="bg-gray-800 p-4 sm:p-6 rounded-2xl shadow-lg border border-gray-700 sticky top-4 z-10 backdrop-blur-sm bg-opacity-80">
            <div class="flex flex-col sm:flex-row gap-2 sm:gap-4 items-start">
                <div class="w-full min-w-0">
                    <label for="expressionInput" class="block text-sm font-medium text-gray-300 mb-2">Enter Boolean Expression:</label>
                    <input type="text" id="expressionInput" class="w-full bg-gray-700 border border-gray-600 text-white rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:outline-none transition font-mono" placeholder="(A && B) || !C">
                </div>
                <div class="w-full sm:w-auto flex flex-row sm:flex-col gap-2 sm:gap-3 mt-2 sm:mt-7 flex-shrink-0">
                    <button id="generateBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition-transform transform hover:scale-105">Generate</button>
                    <button id="clearBtn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg transition-transform transform hover:scale-105">Clear</button>
                </div>
            </div>
        </div>

    <div id="errorContainer" class="mt-4 sm:mt-6 p-3 sm:p-4 bg-red-900/50 border border-red-700 text-red-300 rounded-lg hidden text-sm sm:text-base"></div>

        <div id="outputContainer" class="mt-6 sm:mt-8 hidden">
            <div class="flex flex-nowrap overflow-x-auto border-b border-gray-700 mb-4 sm:mb-6 gap-1 sm:gap-0" role="tablist" style="-webkit-overflow-scrolling: touch;">
                <button class="tab-btn px-4 py-2 font-semibold text-gray-400 rounded-t-lg transition" data-tab="analysis" role="tab" aria-selected="true" tabindex="0">Analysis</button>
                <button class="tab-btn px-4 py-2 font-semibold text-gray-400 rounded-t-lg transition" data-tab="simplification" role="tab" aria-selected="false" tabindex="-1">Simplification</button>
                <button class="tab-btn px-4 py-2 font-semibold text-gray-400 rounded-t-lg transition" data-tab="circuit" role="tab" aria-selected="false" tabindex="-1">Circuit Diagram</button>
                <button class="tab-btn px-4 py-2 font-semibold text-gray-400 rounded-t-lg transition" data-tab="universal" role="tab" aria-selected="false" tabindex="-1">Universal Gates</button>
            </div>

            <div id="tab-analysis" class="tab-content">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 sm:gap-6 mb-6 sm:mb-8">
                    <div class="bg-gray-800 p-4 sm:p-6 rounded-2xl shadow-lg border border-gray-700">
                        <h3 class="text-xl font-semibold mb-3 text-green-300">Sum of Products (SOP)</h3>
                        <p id="minterms" class="text-lg font-mono bg-gray-700 px-3 py-1 rounded break-all"></p>
                    </div>
                    <div class="bg-gray-800 p-4 sm:p-6 rounded-2xl shadow-lg border border-gray-700">
                        <h3 class="text-xl font-semibold mb-3 text-orange-300">Product of Sums (POS)</h3>
                        <p id="maxterms" class="text-lg font-mono bg-gray-700 px-3 py-1 rounded break-all"></p>
                    </div>
                </div>
                
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-4 sm:gap-8">
                    <div>
                        <h2 class="text-xl sm:text-2xl font-bold text-center mb-2 sm:mb-4">Truth Table</h2>
                        <div class="overflow-x-auto bg-gray-800 rounded-2xl shadow-lg border border-gray-700 max-h-[60vh] overflow-y-auto w-full">
                            <table class="min-w-[400px] w-full text-center text-xs sm:text-base">
                                <thead id="tableHeader" class="bg-gray-700 sticky top-0"></thead>
                                <tbody id="tableBody" class="divide-y divide-gray-700"></tbody>
                            </table>
                        </div>
                    </div>
                    <div>
                        <h2 class="text-xl sm:text-2xl font-bold text-center mb-2 sm:mb-4">Karnaugh Map</h2>
                        <div id="kmap-card" class="bg-gray-800 p-2 sm:p-4 rounded-2xl shadow-lg border border-gray-700 flex flex-col items-center justify-center min-h-[200px] sm:min-h-[300px] w-full"></div>
                    </div>
                </div>
            </div>
            
            <div id="tab-simplification" class="tab-content">
                 <div class="bg-gray-800 p-4 sm:p-6 rounded-2xl shadow-lg border border-gray-700">
                    <h2 class="text-xl sm:text-2xl font-bold mb-2 sm:mb-4 text-green-300">Simplified Expression</h2>
                    <p id="simplifiedExpression" class="text-lg sm:text-2xl font-mono bg-gray-700 px-2 sm:px-4 py-2 rounded break-words"></p>
                    <p class="text-xs sm:text-sm text-gray-500 mt-2 sm:mt-4">Note: Simplification is based on algebraic rules and may not always produce the absolute minimal form achievable with K-Maps.</p>
                </div>
            </div>

            <div id="tab-circuit" class="tab-content">
                <div class="bg-gray-800 p-2 sm:p-6 rounded-2xl shadow-lg border border-gray-700">
                    <h2 class="text-xl sm:text-2xl font-bold mb-2 sm:mb-4 text-center text-purple-300">Logic Circuit Diagram</h2>
                    <div id="circuitContainer" class="w-full overflow-x-auto p-2 sm:p-4"></div>
                </div>
            </div>
            
            <div id="tab-universal" class="tab-content">
                <div class="space-y-4 sm:space-y-6">
                    <div class="bg-gray-800 p-3 sm:p-6 rounded-2xl shadow-lg border border-gray-700">
                        <h2 class="text-lg sm:text-xl font-bold mb-2 sm:mb-3 text-orange-300">NAND Gate Implementation</h2>
                        <p id="nandExpression" class="text-sm sm:text-lg font-mono bg-gray-700 p-2 rounded break-all"></p>
                    </div>
                    <div class="bg-gray-800 p-3 sm:p-6 rounded-2xl shadow-lg border border-gray-700">
                        <h2 class="text-lg sm:text-xl font-bold mb-2 sm:mb-3 text-orange-300">NOR Gate Implementation</h2>
                        <p id="norExpression" class="text-sm sm:text-lg font-mono bg-gray-700 p-2 rounded break-all"></p>
                    </div>
                </div>
            </div>
        </div>

        <footer class="text-center text-gray-500 mt-12 py-4 border-t border-gray-800">
            <p class="font-bold">COA - PROJECT</p>
            <p class="text-sm text-gray-400 mt-2">
                Made by:<br>
                AANISH NITHIN A (RA2411003010070)
                &middot;
                AJAY DHARRSAN TR (RA2411003010071)
            </p>
        </footer>
    </div>
    
    <script>
    // --- SCRIPT START --- //

    // DOM Element Lookups
    const expressionInput = document.getElementById('expressionInput');
    const generateBtn = document.getElementById('generateBtn');
    const clearBtn = document.getElementById('clearBtn');
    const outputContainer = document.getElementById('outputContainer');
    const errorContainer = document.getElementById('errorContainer');
    const modal = document.getElementById('instructionsModal');
    const openBtn = document.getElementById('openInstructionsBtn');
    const closeBtn = document.getElementById('closeInstructionsBtn');
    const tabs = document.querySelectorAll('.tab-btn');
    const tabContents = document.querySelectorAll('.tab-content'); // Re-added this selector

    // --- Event Listeners --- //
    generateBtn.addEventListener('click', handleGeneration);
    clearBtn.addEventListener('click', clearAll);
    expressionInput.addEventListener('keyup', (e) => e.key === 'Enter' && handleGeneration());
    
    // Modal Listeners
    openBtn.addEventListener('click', openModal);
    closeBtn.addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => e.target === modal && closeModal());

    // Tab Listeners (corrected selector)
    tabs.forEach((tab, idx) => {
        tab.addEventListener('click', () => {
            tabs.forEach((item, i) => {
                item.classList.remove('active', 'bg-blue-600', 'text-white');
                item.setAttribute('aria-selected', 'false');
                item.setAttribute('tabindex', '-1');
            });
            tab.classList.add('active', 'bg-blue-600', 'text-white');
            tab.setAttribute('aria-selected', 'true');
            tab.setAttribute('tabindex', '0');
            const target = document.getElementById(`tab-${tab.dataset.tab}`);
            tabContents.forEach(content => content.classList.remove('active'));
            if (target) {
                target.classList.add('active');
            }
            tab.focus();
        });
        tab.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight') {
                e.preventDefault();
                tabs[(idx + 1) % tabs.length].click();
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                tabs[(idx - 1 + tabs.length) % tabs.length].click();
            }
        });
    });


    // --- Main Controller --- //
    function handleGeneration() {
        hideError();
        clearOutput();

        try {
            const rawExpression = expressionInput.value.trim();
            if (!rawExpression) throw new Error("Please enter a boolean expression.");
            
            // --- Use the robust parser ---
            const expression = normalizeExpressionRobust(rawExpression); 
            if (!expression) throw new Error("Invalid expression format after normalization.");

            const node = math.parse(expression);
            // Add unique ID to each node for layout tracking
            let nodeId = 0;
            node.traverse(n => n.id = nodeId++);

            const variables = findVariablesRobust(node).sort();
            
            if (variables.length === 0) throw new Error("Expression has no valid single-letter variables.");
            if (variables.length > 8) throw new Error("Too many variables. Please use 8 or fewer for performance.");

            // Generate all necessary data from the expression
            const { truthTableResults, minterms, maxterms } = generateTruthTableData(node, variables);
            const resultsColumn = truthTableResults.map(row => row[row.length - 1]);

            // Render all UI components with the generated data
            renderCanonicalForms(variables, minterms, maxterms);
            renderTruthTable(truthTableResults, [...variables, rawExpression]);
            renderKMap(variables, resultsColumn);
            renderSimplified(expression);
            // --- Call the ENHANCED diagram renderer ---
            renderCircuitDiagramEnhanced(node, variables); 
            renderUniversalGates(node); 
            
            outputContainer.classList.remove('hidden');
            tabs[0].click(); // Activate the first tab by default
        } catch (err) {
            showError(`Error: ${err.message}`);
            clearOutput();
        }
    }
    
    // --- Data Generation and Parsing Functions --- //
    
    // --- ROBUST PARSER ---
     function normalizeExpressionRobust(expr) {
        let normalized = ` ${expr.trim()} `;

        // Universal symbol replacements (safer order)
        normalized = normalized.replace(/&&/g, ' and ')
                               .replace(/\|\|/g, ' or ')
                               .replace(/\s*\+\s*/g, ' or ') // + to or
                               .replace(/!/g, ' not ')      // ! to not
                               .replace(/\^/g, ' xor ');     // ^ to xor

        // Handle prime notation for NOT carefully
        normalized = normalized.replace(/([a-zA-Z0-9])'/g, ' not($1) '); // Single var prime: A'
        // Handle parenthesis prime: (A or B)' - needs careful regex
        normalized = normalized.replace(/\(([^()]*|\(([^()]*|\([^()]*\))*\))*\)'/g, (match) => ` not(${match.slice(0, -1)}) `);

        // Add spaces around operators and parentheses for reliable splitting later
        normalized = normalized.replace(/(\(|\))/g, ' $1 ');
        normalized = normalized.replace(/\s+/g, ' '); // Consolidate multiple spaces

        // ENHANCED: Insert 'and' for implicit multiplication (e.g. ab -> a and b)
        // Only insert 'and' between single-letter variables, not inside keywords
        // Use negative lookbehind and lookahead to avoid keywords
        normalized = normalized.replace(/\b([a-zA-Z])\s*([a-zA-Z])\b/g, function(match, p1, p2) {
            const keywords = ['a','n','d','o','r','x','t'];
            // Only match if both are single-letter variables and not part of a keyword
            if ([p1, p2].every(v => /^[a-zA-Z]$/.test(v)) && !['and','or','not','xor'].includes(match.trim().toLowerCase())) {
                return `${p1} and ${p2}`;
            }
            return match;
        });
        // Insert 'and' between variable and parenthesis: a(b) -> a and (b)
        normalized = normalized.replace(/\b([a-zA-Z])\s*\(/g, '$1 and (');
        // Insert 'and' between parenthesis and variable: )a -> ) and a
        normalized = normalized.replace(/\)\s*([a-zA-Z])\b/g, ') and $1');
        // Remove any double 'and' that may have been inserted
        normalized = normalized.replace(/and\s+and/g, 'and');

        return normalized.trim();
    }


    function findVariablesRobust(node) {
        const variables = new Set();
        const keywords = ['and', 'or', 'not', 'xor', 'true', 'false']; // Keywords to ignore
        node.traverse(n => {
            // Only consider single-letter symbols as variables and exclude keywords
            if (n.isSymbolNode && 
                !keywords.includes(n.name.toLowerCase()) && 
                /^[a-zA-Z]$/.test(n.name)) {
                variables.add(n.name);
            }
        });
        return Array.from(variables);
    }
    
    // --- generateTruthTableData remains the same ---
     function generateTruthTableData(node, variables) {
        const numVars = variables.length;
        const truthTableResults = [], minterms = [], maxterms = [];
        const numRows = Math.pow(2, numVars);

        for (let i = 0; i < numRows; i++) {
            const scope = {}, rowValues = [];
            for (let j = 0; j < numVars; j++) {
                const value = (i >> (numVars - 1 - j)) & 1;
                scope[variables[j]] = value;
                rowValues.push(value);
            }
             try { // Add error handling for evaluation
                const result = node.evaluate(scope) ? 1 : 0;
                rowValues.push(result);
                truthTableResults.push(rowValues);
                if (result === 1) minterms.push(i); else maxterms.push(i);
            } catch (evalError) {
                 // Skip row if evaluation fails, maybe log error
                 console.error(`Evaluation failed for row ${i}, scope:`, scope, evalError);
                 throw new Error(`Failed to evaluate expression for combination ${i}. Check expression syntax. Original error: ${evalError.message}`);
            }
        }
        return { truthTableResults, minterms, maxterms };
    }


    // --- UI Rendering Functions (renderCanonicalForms, renderTruthTable, renderKMap, renderSimplified remain the same) ---
     function renderCanonicalForms(variables, minterms, maxterms) {
        document.getElementById('minterms').textContent = `F(${variables.join(',')}) = Σm(${minterms.join(', ') || ' '})`;
        document.getElementById('maxterms').textContent = `F(${variables.join(',')}) = ΠM(${maxterms.join(', ') || ' '})`;
    }

    function renderTruthTable(data, headers) {
        const tableHeader = document.getElementById('tableHeader');
        const tableBody = document.getElementById('tableBody');
        tableHeader.innerHTML = '';
        tableBody.innerHTML = '';

        const headerRow = document.createElement('tr');
        headers.forEach((h, i) => {
            const th = document.createElement('th');
            th.className = `px-4 py-3 text-sm font-semibold tracking-wider ${i < headers.length - 1 ? 'border-r border-gray-600' : ''}`;
            th.innerHTML = h;
            headerRow.appendChild(th);
        });
        tableHeader.appendChild(headerRow);
        
        data.forEach(rowData => {
            const row = document.createElement('tr');
            row.className = 'even:bg-gray-800 odd:bg-gray-900/50';
            rowData.forEach((cellData, i) => {
                const td = document.createElement('td');
                td.className = `px-4 py-2 ${i < rowData.length - 1 ? 'border-r border-gray-600' : ''}`;
                if (i === rowData.length - 1) {
                   td.className += ' font-bold text-lg';
                   td.classList.add(cellData === 1 ? 'text-green-400' : 'text-red-400');
                }
                td.textContent = cellData;
                row.appendChild(td);
            });
            tableBody.appendChild(row);
        });
    }

    function renderKMap(variables, results) {
        const kmapCard = document.getElementById('kmap-card');
        kmapCard.innerHTML = '';
        const n = variables.length;
        if (n < 2 || n > 4) {
            kmapCard.innerHTML = `<p class="text-gray-400">K-Map is only available for 2, 3, or 4 variables.</p>`;
            return;
        }

        const kmapMappings = { 2: [0, 1, 2, 3], 3: [0, 1, 3, 2, 4, 5, 7, 6], 4: [0, 1, 3, 2, 4, 5, 7, 6, 12, 13, 15, 14, 8, 9, 11, 10] };
        const grayCode = ['00', '01', '11', '10'];
        let rows, cols, rowVars, colVars, rowLabels, colLabels;

        if (n === 2) { [rows, cols] = [2, 2]; [rowVars, colVars] = [variables[0], variables[1]]; rowLabels = grayCode.slice(0,2); colLabels = grayCode.slice(0,2); }
        else if (n === 3) { [rows, cols] = [2, 4]; [rowVars, colVars] = [variables[0], variables.slice(1).join('')]; rowLabels = grayCode.slice(0,2); colLabels = grayCode.slice(0,4); }
        else { [rows, cols] = [4, 4]; [rowVars, colVars] = [variables.slice(0, 2).join(''), variables.slice(2).join('')]; rowLabels = grayCode.slice(0,4); colLabels = grayCode.slice(0,4); }
        
        const grid = document.createElement('div');
        grid.id = 'kmap-grid';
        grid.className = 'grid gap-1 font-mono text-center';
        grid.style.setProperty('--kmap-cols', cols);
        grid.style.setProperty('--kmap-rows', rows);

        grid.innerHTML += `<div class="p-2 text-xs text-gray-400 flex items-end justify-start">${rowVars}<span class="text-lg mx-1">\\</span>${colVars}</div>`;
        colLabels.forEach(l => grid.innerHTML += `<div class="p-2 font-semibold">${l}</div>`);
        
        const mapping = kmapMappings[n];
        for (let r = 0; r < rows; r++) {
            grid.innerHTML += `<div class="p-2 font-semibold">${rowLabels[r]}</div>`;
            for (let c = 0; c < cols; c++) {
                const result = results[mapping[r * cols + c]];
                grid.innerHTML += `<div class="${result === 1 ? 'bg-green-500/30' : 'bg-red-500/20'} rounded flex items-center justify-center text-lg font-bold">${result}</div>`;
            }
        }
        kmapCard.appendChild(grid);
    }
    
    function renderSimplified(expression) {
        const simplifiedEl = document.getElementById('simplifiedExpression');
        try {
            const simplified = math.simplify(expression);
            simplifiedEl.textContent = simplified.toString();
        } catch(e){
            simplifiedEl.textContent = "Could not simplify this expression.";
            console.error("Simplification error:", e); // Log error
        }
    }

    // --- *** ENHANCED & CORRECTED CIRCUIT DIAGRAM RENDERER *** ---
    function renderCircuitDiagramEnhanced(node, variables) {
        const container = document.getElementById('circuitContainer');
        container.innerHTML = ''; // Clear previous diagram
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        container.appendChild(svg);

        const G = { // Geometry constants
            GATE_WIDTH: 60, GATE_HEIGHT: 40, LEVEL_GAP: 120, // Increased gap
            V_GAP: 50, // Increased vertical gap
            INPUT_X: 50, PADDING: 30, WIRE_TURN_OFFSET: 20
        };

        const layout = {}; // Stores { x, y, depth, height } for each node
        const varYPos = {};
        variables.forEach((v, i) => varYPos[v] = G.PADDING + (i * (G.GATE_HEIGHT + G.V_GAP)));

        // Pass 1: Calculate layout recursively (Post-order traversal)
        function calculateLayout(n) {
            if (layout[n.id]) return layout[n.id]; // Memoization

            if (n.isSymbolNode) {
                const y = varYPos[n.name] + G.GATE_HEIGHT / 2;
                return layout[n.id] = { depth: 0, y: y, height: 0, x: G.INPUT_X, isVar: true, name: n.name };
            }
            if (n.isParenthesisNode) {
                 // Parentheses don't add depth, pass layout call to content
                 const contentLayout = calculateLayout(n.content);
                 // Store layout for parenthesis node itself, inheriting from content
                 return layout[n.id] = { ...contentLayout, isParen: true };
            }

            // Operator Node
            const childrenLayouts = n.args.map(calculateLayout);
            const maxChildDepth = Math.max(0, ...childrenLayouts.map(l => l.depth));
            
            const depth = maxChildDepth + 1;
            const x = G.INPUT_X + depth * G.LEVEL_GAP;
            
            // Calculate y based on children's average y, ensuring minimum spacing
            let y;
            if (childrenLayouts.length > 0) {
                 const avgY = childrenLayouts.reduce((sum, l) => sum + l.y, 0) / childrenLayouts.length;
                 // Prevent gates from overlapping vertically
                 let requiredHeight = (childrenLayouts.length - 1) * (G.GATE_HEIGHT + G.V_GAP);
                 y = avgY;
                 // Adjust y position based on previous sibling at the same depth to prevent overlap
                 const siblingsAtDepth = Object.values(layout).filter(l => l.depth === depth && !l.isVar && !l.isParen);
                 let maxY = 0;
                 siblingsAtDepth.forEach(sib => { maxY = Math.max(maxY, sib.y + sib.height / 2); });
                 y = Math.max(y, maxY + G.V_GAP + G.GATE_HEIGHT / 2);

            } else {
                 y = G.PADDING + G.GATE_HEIGHT / 2; // Should not happen with valid expressions
            }

            const height = Math.max(G.GATE_HEIGHT, (childrenLayouts.length - 1) * G.V_GAP + G.GATE_HEIGHT ); // Ensure min height


            return layout[n.id] = { depth, x, y, height, children: childrenLayouts, op: n.op };
        }
        
        const rootLayout = calculateLayout(node);

        // Adjust coordinates if needed (optional, for centering)
        // Find max dimensions after initial layout
        let maxX = 0;
        let maxY = 0;
         Object.values(layout).forEach(l => {
             if (!l.isVar) {
                maxX = Math.max(maxX, l.x + G.GATE_WIDTH / 2);
                maxY = Math.max(maxY, l.y + l.height / 2);
             } else {
                 maxY = Math.max(maxY, l.y);
             }
         });
        const maxWidth = maxX + G.LEVEL_GAP + G.PADDING; // Add gap for output line
        const maxHeight = Math.max(maxY, Math.max(...Object.values(varYPos)) + G.GATE_HEIGHT / 2) + G.PADDING;


        svg.setAttribute('width', maxWidth);
        svg.setAttribute('height', maxHeight);
        svg.setAttribute('viewBox', `0 0 ${maxWidth} ${maxHeight}`);

        let svgElements = '';

        // Pass 2: Draw everything using the pre-calculated layout.
        // Draw input variable lines first
        variables.forEach(v => {
            const y = varYPos[v] + G.GATE_HEIGHT / 2;
            svgElements += `<text class="input-label" x="${G.PADDING/2}" y="${y + 5}">${v}</text>`;
            let maxVarX = G.INPUT_X;
            Object.values(layout).forEach(l => { if (l.isVar && l.name === v) maxVarX = Math.max(maxVarX, l.x); });
            svgElements += `<line class="wire" x1="${G.INPUT_X}" y1="${y}" x2="${maxWidth - G.PADDING}" y2="${y}" />`;
        });
        const drawnNodes = new Set();
        function draw(n) {
            if (!layout[n.id] || drawnNodes.has(n.id)) return;
            drawnNodes.add(n.id);
            if (n.isOperatorNode) {
                const l = layout[n.id];
                const gateX = l.x;
                const gateY = l.y - G.GATE_HEIGHT / 2;
                let gateSymbol = '';
                let gateLabel = '';
                l.children.forEach((child, i) => {
                    const inputY = (l.children.length === 1) ? l.y : gateY + (i + 1) * (G.GATE_HEIGHT / (l.children.length + 1));
                    const childOutputX = child.isVar ? child.x : child.x + G.GATE_WIDTH / 2;
                    const childOutputY = child.y;
                    svgElements += `<polyline class="wire" points="${childOutputX},${childOutputY} ${gateX - G.WIRE_TURN_OFFSET},${childOutputY} ${gateX - G.WIRE_TURN_OFFSET},${inputY} ${gateX},${inputY}" />`;
                    const childNode = n.args.find(argNode => layout[argNode.id] === child);
                    if(childNode) draw(childNode);
                });
                switch (n.op) {
                    case 'and':
                        gateSymbol = `<path d="M ${gateX},${gateY} H ${gateX + G.GATE_WIDTH/2} A ${G.GATE_WIDTH/2} ${G.GATE_HEIGHT/2} 0 0 1 ${gateX + G.GATE_WIDTH/2},${gateY+G.GATE_HEIGHT} H ${gateX} Z" />`;
                        gateLabel = 'AND';
                        break;
                    case 'or':
                        gateSymbol = `<path d="M ${gateX-5},${gateY} Q ${gateX+10},${gateY} ${gateX+G.GATE_WIDTH},${l.y} Q ${gateX+10},${gateY+G.GATE_HEIGHT} ${gateX-5},${gateY+G.GATE_HEIGHT} Q ${gateX+5},${l.y} ${gateX-5},${gateY} Z" />`;
                        gateLabel = 'OR';
                        break;
                    case 'xor':
                        gateSymbol = `<path d="M ${gateX-10},${gateY} Q ${gateX-5},${l.y} ${gateX-10},${gateY+G.GATE_HEIGHT}" class="wire"/>` + `<path d="M ${gateX-5},${gateY} Q ${gateX+10},${gateY} ${gateX+G.GATE_WIDTH},${l.y} Q ${gateX+10},${gateY+G.GATE_HEIGHT} ${gateX-5},${gateY+G.GATE_HEIGHT} Q ${gateX+5},${l.y} ${gateX-5},${gateY} Z" />`;
                        gateLabel = 'XOR';
                        break;
                    case 'not':
                        gateSymbol = `<path d="M ${gateX},${gateY} L ${gateX+G.GATE_WIDTH-10},${l.y} L ${gateX},${gateY+G.GATE_HEIGHT} Z" /><circle cx="${gateX+G.GATE_WIDTH-5}" cy="${l.y}" r="5" fill="#374151" stroke="#9ca3af" stroke-width="2"/>`;
                        gateLabel = 'NOT';
                        break;
                }
                svgElements += `<g class="gate-body">${gateSymbol}<text x="${gateX + G.GATE_WIDTH/4}" y="${l.y + 6}" font-size="14" fill="#fff" font-weight="bold" text-anchor="middle">${gateLabel}</text></g>`;
            } else if (n.isSymbolNode) {
                const l = layout[n.id];
                svgElements += `<circle class="wire-junction" cx="${l.x}" cy="${l.y}" r="4" />`;
            } else if (n.isParenthesisNode) {
                draw(n.content);
            }
        }
        draw(node);
        const finalOutputX = rootLayout.x + G.GATE_WIDTH / 2;
        const finalOutputY = rootLayout.y;
        svgElements += `<line class="wire" x1="${finalOutputX}" y1="${finalOutputY}" x2="${finalOutputX + G.LEVEL_GAP/2}" y2="${finalOutputY}" />`;
        svgElements += `<text class="input-label" x="${finalOutputX + G.LEVEL_GAP/2 + 10}" y="${finalOutputY + 5}">F</text>`;
        svg.innerHTML = svgElements;
    }


    function renderUniversalGates(originalNode) {
        const nandEl = document.getElementById('nandExpression');
        const norEl = document.getElementById('norExpression');

        try {
            const simplifiedNode = math.simplify(originalNode);

            function toNAND(n) {
                if (n.isSymbolNode) return n.name;
                if (n.isParenthesisNode) return `(${toNAND(n.content)})`;
                if (n.isOperatorNode) {
                    const args = n.args.map(toNAND);
                    switch(n.op) {
                        case 'not': return `(${args[0]} NAND ${args[0]})`;
                        case 'and': return `((${args[0]} NAND ${args[1]}) NAND (${args[0]} NAND ${args[1]}))`;
                        case 'or':  return `((${args[0]} NAND ${args[0]}) NAND (${args[1]} NAND ${args[1]}))`;
                        case 'xor': return toNAND(math.parse(`(${n.args[0].toString()} or ${n.args[1].toString()}) and not (${n.args[0].toString()} and ${n.args[1].toString()})`));
                    }
                }
                return '';
            }

            function toNOR(n) {
                if (n.isSymbolNode) return n.name;
                if (n.isParenthesisNode) return `(${toNOR(n.content)})`;
                if (n.isOperatorNode) {
                    const args = n.args.map(toNOR);
                    switch(n.op) {
                        case 'not': return `(${args[0]} NOR ${args[0]})`;
                        case 'or': return `((${args[0]} NOR ${args[1]}) NOR (${args[0]} NOR ${args[1]}))`;
                        case 'and': return `((${args[0]} NOR ${args[0]}) NOR (${args[1]} NOR ${args[1]}))`;
                        case 'xor': return toNOR(math.parse(`(${n.args[0].toString()} or ${n.args[1].toString()}) and not (${n.args[0].toString()} and ${n.args[1].toString()})`));
                    }
                }
                return '';
            }
            
            nandEl.textContent = toNAND(simplifiedNode).replace(/NAND/g, ' NAND ');
            norEl.textContent = toNOR(simplifiedNode).replace(/NOR/g, ' NOR ');
        } catch (e) {
            nandEl.textContent = "Could not convert to NAND gates.";
            norEl.textContent = "Could not convert to NOR gates.";
            console.error("Universal gate conversion error:", e); // Log error
        }
    }

    // --- Utility & UI Helper Functions --- //
    function clearAll() {
        expressionInput.value = '';
        clearOutput();
        hideError();
    }
    
    function clearOutput() {
        outputContainer.classList.add('hidden');
    }

    function showError(message) {
        errorContainer.innerHTML = `<strong>Error:</strong> <span>${message.replace('Error:', '').trim()}</span>`;
        errorContainer.classList.remove('hidden');
        errorContainer.setAttribute('role', 'alert');
        errorContainer.setAttribute('tabindex', '0');
        errorContainer.focus();
    }
    
    function hideError() {
        errorContainer.classList.add('hidden');
    }
    
    function openModal() {
        modal.classList.remove('hidden');
        document.body.style.overflow = 'hidden';
        setTimeout(() => {
            modal.classList.remove('pointer-events-none', 'opacity-0');
            modal.querySelector('div').classList.remove('scale-95');
            modal.querySelector('div').focus();
        }, 10);
    }

    function closeModal() {
        document.body.style.overflow = '';
        modal.classList.add('pointer-events-none', 'opacity-0');
        modal.querySelector('div').classList.add('scale-95');
        setTimeout(() => modal.classList.add('hidden'), 300);
        openBtn.focus();
    }
    </script>
</body>
</html>